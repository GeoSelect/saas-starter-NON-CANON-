-- Migration Template for Supabase
--
-- Naming: YYYYMMDD_HHmmss_description.sql (auto-generated by Supabase CLI)
-- Or: NNN_description.sql (manual numbering)
--
-- Guidelines:
-- 1. Each migration should be IDEMPOTENT (safe to run multiple times)
-- 2. Use IF NOT EXISTS, IF EXISTS to avoid errors
-- 3. Include meaningful comments
-- 4. Keep migrations focused and atomic
-- 5. Test on development database first

-- ============================================================================
-- SECURITY: Enable RLS (Row Level Security)
-- ============================================================================
-- RLS policies restrict data access by workspace/user
-- Always enable on tables that contain user/workspace data

-- ============================================================================
-- Example: Create a Parcels Table with RLS
-- ============================================================================

-- Drop if exists (for testing; remove in production)
-- DROP TABLE IF EXISTS parcels CASCADE;

CREATE TABLE IF NOT EXISTS parcels (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id UUID NOT NULL,
  user_id UUID NOT NULL,
  name VARCHAR(255) NOT NULL,
  address VARCHAR(500),
  apn VARCHAR(50),
  jurisdiction VARCHAR(255),
  centroid GEOMETRY(Point, 4326),
  status VARCHAR(20) DEFAULT 'active',
  deleted_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_by UUID,
  CONSTRAINT fk_workspace FOREIGN KEY (workspace_id) REFERENCES workspaces(id) ON DELETE CASCADE,
  CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_parcels_workspace_id ON parcels(workspace_id);
CREATE INDEX IF NOT EXISTS idx_parcels_user_id ON parcels(user_id);
CREATE INDEX IF NOT EXISTS idx_parcels_deleted_at ON parcels(deleted_at);
CREATE INDEX IF NOT EXISTS idx_parcels_centroid ON parcels USING GIST(centroid);
CREATE INDEX IF NOT EXISTS idx_parcels_workspace_deleted ON parcels(workspace_id, deleted_at);

-- Auto-update timestamp
CREATE OR REPLACE FUNCTION update_parcels_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS parcels_updated_at_trigger ON parcels;
CREATE TRIGGER parcels_updated_at_trigger
BEFORE UPDATE ON parcels
FOR EACH ROW
EXECUTE FUNCTION update_parcels_updated_at();

-- ============================================================================
-- RLS POLICIES: Restrict access to workspace members only
-- ============================================================================

-- Enable RLS on the table
ALTER TABLE parcels ENABLE ROW LEVEL SECURITY;

-- Policy 1: Users can only see parcels in their workspace
CREATE POLICY parcels_select_workspace ON parcels
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM workspace_members
      WHERE workspace_members.workspace_id = parcels.workspace_id
        AND workspace_members.user_id = auth.uid()
    )
  );

-- Policy 2: Users can only insert parcels in their workspace
CREATE POLICY parcels_insert_workspace ON parcels
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM workspace_members
      WHERE workspace_members.workspace_id = parcels.workspace_id
        AND workspace_members.user_id = auth.uid()
        AND workspace_members.role IN ('owner', 'editor')
    )
  );

-- Policy 3: Users can only update parcels in their workspace
CREATE POLICY parcels_update_workspace ON parcels
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM workspace_members
      WHERE workspace_members.workspace_id = parcels.workspace_id
        AND workspace_members.user_id = auth.uid()
        AND workspace_members.role IN ('owner', 'editor')
    )
  );

-- Policy 4: Users can only delete (soft-delete) parcels in their workspace
CREATE POLICY parcels_delete_workspace ON parcels
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM workspace_members
      WHERE workspace_members.workspace_id = parcels.workspace_id
        AND workspace_members.user_id = auth.uid()
        AND workspace_members.role = 'owner'
    )
  );

-- ============================================================================
-- Audit Trail Integration (Optional)
-- ============================================================================
-- Log all parcel changes to audit_events

CREATE OR REPLACE FUNCTION log_parcel_changes()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO audit_events (
    workspace_id,
    user_id,
    event_type,
    resource_type,
    resource_id,
    metadata
  ) VALUES (
    NEW.workspace_id,
    COALESCE(auth.uid(), NEW.user_id),
    TG_OP::TEXT,
    'parcel',
    NEW.id,
    jsonb_build_object(
      'old', TO_JSONB(OLD),
      'new', TO_JSONB(NEW)
    )
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS parcels_audit_trigger ON parcels;
CREATE TRIGGER parcels_audit_trigger
AFTER INSERT OR UPDATE ON parcels
FOR EACH ROW
EXECUTE FUNCTION log_parcel_changes();

-- ============================================================================
-- Post-Migration Verification
-- ============================================================================
-- Run this to verify the migration succeeded:
/*

SELECT 'parcels' AS table_name, COUNT(*) AS row_count FROM parcels;

SELECT indexname FROM pg_indexes WHERE tablename = 'parcels';

SELECT schemaname, tablename FROM pg_tables WHERE tablename = 'parcels';

SELECT * FROM information_schema.tables WHERE table_name = 'parcels';

*/
